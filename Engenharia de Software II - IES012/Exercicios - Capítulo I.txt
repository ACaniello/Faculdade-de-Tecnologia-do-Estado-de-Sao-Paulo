1 - Segundo Frederick Brooks, desenvolvimento de software enfrenta dificuldades essenciais (para as quais não há bala de prata) e acidentais (para as quais existe uma solução melhor).
Dê exemplo de dificuldade acidental que já tenha experimentado ao desenvolver programas, mesmo que pequenos. 
Sugestão: elas pode estar relacionadas a ferramentas que tenha usado, como compiladores, IDEs, banco de dados, sistemas operacionais, etc.

Resposta: As dificuldades essenciais relatadas por F Brooks, estão relacionadas às mudanças de paradigmas que não necessariamente tem relação com o produto, como as leis de um país por exemplo, caso aconteça novas regulamentações,
as empresas de software necessitam seguir as práticas corretas para que seu(s) produto(s) sigam no mercado conforme as leis e regulamentações.
As dificuldades acidentais, estão relacionadas a diferentes problemas técnicos que podem surgir com o tempo e de responsabilidade dos profissionais da área encontrarem uma solução: atualizações nas IDEs, uso correto de frameworks,
modificações necessárias para que o software encontre um estado de melhor funcionamento.

2 - Diferencie requisitos funcionais de requisitos não-funcionais.

Resposta: Requisitos funcionais estão ligados ao negócio, o que o software necessita fazer, exemplo de uma padaria: entrada de alimentos na comanda do cliente.
Os sistemas não-funcionais tem a ver com o como o sistema deve funcionar, exemplo de uma padaria: sistema será funcional por 24h/7dias, sistema utilizará linux como forma principal para rodar o sistema.

3 - Explique por que testes podem ser considerados tanto uma atividade de verificação como de validação de software. 
Qual tipo de teste é mais adequado se o objetivo for verificação? Qual tipo de teste é mais adequado se o objetivo for validar um sistema de software?

Resposta: O teste de verificação serve para garantir às suas determinadas especificações atenda ao cliente e a validação serve para garantir que o sistema  atenda às necessidades do cliente.
Os testes mais adequados para as verificações do software são os testes de integração e teste de performance.
Os testes mais adequados para as validações são os testes de performance e usabilidade.

4 - Por que testes não conseguem provar a ausência de bugs?

Resposta: Porque nem sempre o teste será falho, algumas variáveis podem estar calculando errado por exemplo.

5 - Suponha um programa que tenha uma única entrada? um inteiro de 64 bits. Em um teste exaustivo, temos que testar esse programa como todos os possíveis inteiros (logo 2elevadoa64).
Se cada teste levar 1 nanossegundo 10(elevadoa-9 segundos), quanto tempo levará esse teste exaustivo?

Resposta: 

6 - Se considerarmos o contexto histórico, porque foi natural que os primeiros processos de desenvolvimento de software tivessem características sequenciais e fossem baseados em planejamento e documentação detalhados?

Resposta: Porque seguiam um legado das outras diferentes engenharias, mesmo sendo produzida de forma diferente, os primeiros softwares seguiam modelos cascata que eram bem estruturados e detalhados em sequência.

7 - Alguns estudos mostram que os custos com manutenção e evolução podem alcançar 80% ou mais dos custos totais alocados a um sistema de software, durante todo o seu ciclo de vida. Explique porque esse valor é tão alto.

Resposta: Fazer a manutenção de um software pode ser elevar o custo por 'n' motivos: estudo do que já foi documentado e próximos passos para realizar a manutenção e/ou melhoria do sistemas por exemplo, isso custa muito a uma empresa. Em questão de evolução: fazer uma ponte entre Dev e Ops para realizar uma evolução do sistema pode ser uma tática demorada para as empresas, devido aos custos não só de software mas de infraestrutura que isso pode causar. Além de claro, possívelmente gerar novos bugs - necessidade de correção maiores.

8 - Refactoring é uma transformação de código que preserva comportamento.
Qual o significado da expressão preservar comportamento? Na prática, qual restrição ela impõe a uma operação de refactoring?

Resposta: O significado é literalmente a preservação da forma como o software funciona, ou seja, melhorar o código sem necessariamente causar alterações na forma como ele se comporta: sistemas de foftware de bancos são um exemplo.
As restrições são em questões do uso correto da linguagem utilizado pelo sistema, seja um COBOL ou um Java, respeitando sua versão de uso.

9 - Dê exemplos de sistemas A (Acute, ou críticos) e B (Business, ou comerciais) com os quais já tenha interagido.

Resposta: 
Sistema A: Nunca interagi com um sistema crítico mas já, de uma forma ou outra, estava dentro de um: viagem de avião. O sistema utilizado em um avião é um sistema crítico.
Sistema B: Criar páginas de e-commerce para testes.

10 - Dê exemplos de sistemas C (casuais) que você já tenha desenvolvido.

Resposta:
Sistema C: Diferentes programas requisitados pelos professores em sala de aula: scripts em java para leitura de algum programa por exemplo.

11 - Em 2015, descobriu-se que o software instalado em mais de 11 milhões de carros da Volkswagen detectava quando eles estavam sendo testados em um laboratório de certificação.
Nessas situações, o carro emitia poluentes dentro das normas legais.
Fora do laboratório, emitia-se mais poluentes, para melhorar o desempenho.
Ou seja, o código incluía uma estrutura de decisão como a seguinte (meramente ilustrativa, para fins deste exercício):

if "Carro sendo testado em um laboratório"
	"Emita poluentes dentro das normas"
else
	"Emita poluentes fora das normas"

O que você faria se seu chefe pedisse para escrever um if como o acima? Para mais informações sobre esse episódio, consulte a página da Wikipédia.
https://en.wikipedia.org/wiki/Volkswagen_emissions_scandal

Resposta: Esse programa, tanto na criação quanto em sua utilização, violam práticas tanto da profissão de engenheiro de software, quanto leis ambientais do país (sem entrar em termos técnicos com relação as muitas práticas que foram violadas no mercado contra a concorrência também).